// RUN: kecc-opt %s --canonicalize-constant --mem2reg | FileCheck %s

fun i32 @multi_location () {
// CHECK: fun i32 @multi_location ()
init:
  bid: b666
  allocations:
    %l0:i32:x
    %l1:i16:y
    %l2:i64:z
    %l3:i8:w
// CHECK-NEXT: init:
// CHECK-NEXT:  bid: b666
// CHECK-NEXT:  allocations:
// CHECK-NEXT:    %l0:i32:x
// CHECK-NEXT:    %l1:i16:y
// CHECK-NEXT:    %l2:i64:z
// CHECK-NEXT:    %l3:i8:w


block b666:
// CHECK-LABEL: block b666:
  %b666:i0:unit = store 42:i8 %l3:i8*
  // CHECK-NEXT: %b666:i0:unit = store 42:i8 %l3:i8*
  %b666:i1:unit = call @sinkptr:[ret:unit params:(i8*)]*(%l3:i8*)
  // CHECK-NEXT: %b666:i1:unit = call @sinkptr:[ret:unit params:(i8*)]*(%l3:i8*)
  %b666:i2:i8 = load %l3:i8*
  // CHECK-NEXT: %b666:i2:i8 = load %l3:i8*
  j b0()
  // CHECK-NEXT: j b0(undef:i32, undef:i16, undef:i64)

block b0:
// CHECK-LABEL: block b0:
  // CHECK-NEXT: %b0:p0:i32:x
  // CHECK-NEXT: %b0:p1:i16:y
  // CHECK-NEXT: %b0:p2:i64:z

  %b0:i0:i32 = load %l0:i32*
  // CHECK-NEXT: %b0:i0:unit = nop 
  %b0:i1:unit = call @sink:[ret:unit params:(i32)]*(%b0:i0:i32)
  // CHECK-NEXT: %b0:i1:unit = call @sink:[ret:unit params:(i32)]*(%b0:p0:i32)
  %b0:i2:unit = store 0:i32 %l0:i32*
  // CHECK-NEXT: %b0:i2:unit = nop 

  %b0:i3:i16 = load %l1:i16*
  // CHECK-NEXT: %b0:i3:unit = nop
  %b0:i4:i32 = typecast %b0:i3:i16 to i32
  // CHECK-NEXT: %b0:i4:i32 = typecast %b0:p1:i16 to i32
  %b0:i5:unit = call @sink:[ret:unit params:(i32)]*(%b0:i4:i32)
  // CHECK-NEXT: %b0:i5:unit = call @sink:[ret:unit params:(i32)]*(%b0:i4:i32)
  %b0:i6:unit = store 1:i16 %l1:i16*
  // CHECK-NEXT: %b0:i6:unit = nop 

  %b0:i7:i64 = load %l2:i64*
  // CHECK-NEXT: %b0:i7:unit = nop
  %b0:i8:i32 = typecast %b0:i7:i64 to i32
  // CHECK-NEXT: %b0:i8:i32 = typecast %b0:p2:i64 to i32
  %b0:i9:unit = call @sink:[ret:unit params:(i32)]*(%b0:i8:i32)
  // CHECK-NEXT: %b0:i9:unit = call @sink:[ret:unit params:(i32)]*(%b0:i8:i32)
  %b0:i10:unit = store 2:i64 %l2:i64*
  // CHECK-NEXT: %b0:i10:unit = nop 

  switch undef:i32 default b1() [
    2:i32 b2()
    3:i32 b3()
  ]
  // CHECK-NEXT: switch undef:i32 default b1() [
  // CHECK-NEXT:   2:i32 b2(0:i32)
  // CHECK-NEXT:   3:i32 b3()
  // CHECK-NEXT: ]


block b1:
// CHECK-LABEL: block b1:
  %b1:i0:i32 = load %l0:i32*
  // CHECK-NEXT: %b1:i0:unit = nop
  %b1:i1:unit = call @sink:[ret:unit params:(i32)]*(%b1:i0:i32)
  // CHECK-NEXT: %b1:i1:unit = call @sink:[ret:unit params:(i32)]*(0:i32)
  %b1:i2:unit = store 100:i32 %l0:i32*
  // CHECK-NEXT: %b1:i2:unit = nop 

  %b1:i3:i64 = load %l2:i64*
  // CHECK-NEXT: %b1:i3:unit = nop 
  %b1:i4:i32 = typecast %b1:i3:i64 to i32
  // CHECK-NEXT: %b1:i4:i32 = typecast 2:i64 to i32
  %b1:i5:unit = call @sink:[ret:unit params:(i32)]*(%b1:i4:i32)
  // CHECK-NEXT: %b1:i5:unit = call @sink:[ret:unit params:(i32)]*(%b1:i4:i32)
  %b1:i6:unit = store 102:i64 %l2:i64*
  // CHECK-NEXT: %b1:i6:unit = nop 

  j b2()
  // CHECK-NEXT: j b2(100:i32)

block b2:
// CHECK-LABEL: block b2:
  // CHECK-NEXT:  %b2:p0:i32:x
  %b2:i0:i32 = load %l0:i32*
  // CHECK-NEXT: %b2:i0:unit = nop
  %b2:i1:unit = call @sink:[ret:unit params:(i32)]*(%b2:i0:i32)
  // CHECK-NEXT: %b2:i1:unit = call @sink:[ret:unit params:(i32)]*(%b2:p0:i32)
  %b2:i2:unit = store 200:i32 %l0:i32*
  // CHECK-NEXT: %b2:i2:unit = nop 

  %b2:i3:i16 = load %l1:i16*
  // CHECK-NEXT: %b2:i3:unit = nop 
  %b2:i4:i32 = typecast %b2:i3:i16 to i32
  // CHECK-NEXT: %b2:i4:i32 = typecast 1:i16 to i32
  %b2:i5:unit = call @sink:[ret:unit params:(i32)]*(%b2:i4:i32)
  // CHECK-NEXT: %b2:i5:unit = call @sink:[ret:unit params:(i32)]*(%b2:i4:i32)
  %b2:i6:unit = store 201:i16 %l1:i16*
  // CHECK-NEXT: %b2:i6:unit = nop 

  j b3()
  // CHECK-NEXT: j b3() 

block b3:
// CHECK-LABEL: block b3:
  %b3:i0:unit = store 300:i32 %l0:i32*
  // CHECK-NEXT: %b3:i0:unit = nop 
  %b3:i1:unit = store 301:i16 %l1:i16*
  // CHECK-NEXT: %b3:i1:unit = nop 
  %b3:i2:unit = store 302:i64 %l2:i64*
  // CHECK-NEXT: %b3:i2:unit = nop 

  j b0()
  // CHECK-NEXT: j b0(300:i32, 301:i16, 302:i64)
}
