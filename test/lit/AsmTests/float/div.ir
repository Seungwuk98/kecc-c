// RUN: kecc-test-executor %s -dump-source=0 | kecc-translate | FileCheck %s


fun f32 @div_f32 (f32, f32) {
init:
  bid: b0
  allocations:

block b0:
  %b0:p0:f32
  %b0:p1:f32
  %b0:i0:f32 = div %b0:p0:f32 %b0:p1:f32
  ret %b0:i0:f32
}

// CHECK:   .globl	div_f32
// CHECK-NEXT:   .align	1
// CHECK-NEXT:   .type	div_f32, @function
// CHECK-NEXT: div_f32:

// CHECK-LABEL: .div_f32_L0:
// CHECK-NEXT:   fdiv.s	fa0,fa0,fa1
// CHECK-NEXT:   ret


fun f64 @div_f64 (f64, f64) {
init:
  bid: b0
  allocations:

block b0:
  %b0:p0:f64
  %b0:p1:f64
  %b0:i0:f64 = div %b0:p0:f64 %b0:p1:f64
  ret %b0:i0:f64
}

// CHECK:   .globl	div_f64
// CHECK-NEXT:   .align	1
// CHECK-NEXT:   .type	div_f64, @function
// CHECK-NEXT: div_f64:

// CHECK-LABEL: .div_f64_L0:
// CHECK-NEXT:   fdiv.d	fa0,fa0,fa1
// CHECK-NEXT:   ret


//////// main.c
// RUN: kecc-test-executor %s | FileCheck %s --check-prefix=RESULT

#include <stdio.h>
#include <stdint.h>
#include <math.h>

extern float  div_f32(float, float);
extern double div_f64(double, double);

int main(void) {
  // ===== f32 (float) =====
  // zeros & signed zeros
  printf("%a\n", (double) div_f32(0.0f, 1.0f));
  // RESULT: 0x0p+0
  printf("%a\n", (double) div_f32(-0.0f, 1.0f));
  // RESULT: -0x0p+0
  printf("%a\n", (double) div_f32(0.0f, -1.0f));
  // RESULT: -0x0p+0
  printf("%a\n", (double) div_f32(-0.0f, -1.0f));
  // RESULT: 0x0p+0

  // finite / finite
  printf("%a\n", (double) div_f32(1.0f, 2.0f));
  // RESULT: 0x1p-1
  printf("%a\n", (double) div_f32(-1.0f, 2.0f));
  // RESULT: -0x1p-1
  printf("%a\n", (double) div_f32(1.5f, 2.0f));
  // RESULT: 0x1.8p-1
  printf("%a\n", (double) div_f32(-2.5f, 4.0f));
  // RESULT: -0x1.4p-1

  // normal/subnormal boundaries
  printf("%a\n", (double) div_f32(0x1.fffffep+127f, 2.0f));   // FLT_MAX / 2
  // RESULT: 0x1.fffffep+126
  printf("%a\n", (double) div_f32(0x1.fffffep+127f, 0.5f));   // FLT_MAX / 0.5 -> overflow
  // RESULT: inf
  printf("%a\n", (double) div_f32(0x1p-126f, 2.0f));          // min normal / 2 = subnormal
  // RESULT: 0x1p-127
  printf("%a\n", (double) div_f32(0x1p-149f, 2.0f));          // min subnormal / 2 -> underflow to +0
  // RESULT: 0x0p+0
  printf("%a\n", (double) div_f32(0x1p-149f, -1.0f));         // sign preserved for subnormal
  // RESULT: -0x1p-149

  // infinities & NaNs
  printf("%a\n", (double) div_f32(INFINITY, 2.0f));
  // RESULT: inf
  printf("%a\n", (double) div_f32(-INFINITY, -2.0f));
  // RESULT: inf
  printf("%a\n", (double) div_f32(3.0f, INFINITY));
  // RESULT: 0x0p+0
  printf("%a\n", (double) div_f32(-3.0f, INFINITY));
  // RESULT: -0x0p+0
  printf("%a\n", (double) div_f32(INFINITY, INFINITY));
  // RESULT: nan
  printf("%a\n", (double) div_f32(NAN, 1.0f));
  // RESULT: nan
  printf("%a\n", (double) div_f32(1.0f, NAN));
  // RESULT: nan

  // division by zero (IEEE-754)
  printf("%a\n", (double) div_f32(3.0f, 0.0f));
  // RESULT: inf
  printf("%a\n", (double) div_f32(-3.0f, 0.0f));
  // RESULT: -inf
  printf("%a\n", (double) div_f32(3.0f, -0.0f));
  // RESULT: -inf
  printf("%a\n", (double) div_f32(-3.0f, -0.0f));
  // RESULT: inf
  printf("%a\n", (double) div_f32(0.0f, 0.0f));
  // RESULT: nan
  printf("%a\n", (double) div_f32(-0.0f, 0.0f));
  // RESULT: nan
  printf("%a\n", (double) div_f32(0.0f, -0.0f));
  // RESULT: nan
  printf("%a\n", (double) div_f32(-0.0f, -0.0f));
  // RESULT: nan

  // ===== f64 (double) =====
  // zeros & signed zeros
  printf("%a\n", div_f64(0.0, 1.0));
  // RESULT: 0x0p+0
  printf("%a\n", div_f64(-0.0, 1.0));
  // RESULT: -0x0p+0
  printf("%a\n", div_f64(0.0, -1.0));
  // RESULT: -0x0p+0
  printf("%a\n", div_f64(-0.0, -1.0));
  // RESULT: 0x0p+0

  // finite / finite
  printf("%a\n", div_f64(1.0, 2.0));
  // RESULT: 0x1p-1
  printf("%a\n", div_f64(-1.0, 2.0));
  // RESULT: -0x1p-1
  printf("%a\n", div_f64(1.5, 2.0));
  // RESULT: 0x1.8p-1
  printf("%a\n", div_f64(-2.5, 4.0));
  // RESULT: -0x1.4p-1

  // normal/subnormal boundaries
  printf("%a\n", div_f64(0x1.fffffffffffffp+1023, 2.0));     // DBL_MAX / 2
  // RESULT: 0x1.fffffffffffffp+1022
  printf("%a\n", div_f64(0x1.fffffffffffffp+1023, 0.5));     // DBL_MAX / 0.5 -> overflow
  // RESULT: inf
  printf("%a\n", div_f64(0x1p-1022, 2.0));                   // min normal / 2 = subnormal
  // RESULT: 0x0.8p-1022
  printf("%a\n", div_f64(0x1p-1074, 2.0));                   // min subnormal / 2 -> +0
  // RESULT: 0x0p+0
  printf("%a\n", div_f64(0x1p-1074, -1.0));                  // keep sign for subnormal
  // RESULT: -0x0.0000000000001p-1022

  // infinities & NaNs
  printf("%a\n", div_f64(INFINITY, 2.0));
  // RESULT: inf
  printf("%a\n", div_f64(-INFINITY, -2.0));
  // RESULT: inf
  printf("%a\n", div_f64(3.0, INFINITY));
  // RESULT: 0x0p+0
  printf("%a\n", div_f64(-3.0, INFINITY));
  // RESULT: -0x0p+0
  printf("%a\n", div_f64(INFINITY, INFINITY));
  // RESULT: nan
  printf("%a\n", div_f64(NAN, 1.0));
  // RESULT: nan
  printf("%a\n", div_f64(1.0, NAN));
  // RESULT: nan

  // division by zero (IEEE-754)
  printf("%a\n", div_f64(3.0, 0.0));
  // RESULT: inf
  printf("%a\n", div_f64(-3.0, 0.0));
  // RESULT: -inf
  printf("%a\n", div_f64(3.0, -0.0));
  // RESULT: -inf
  printf("%a\n", div_f64(-3.0, -0.0));
  // RESULT: inf
  printf("%a\n", div_f64(0.0, 0.0));
  // RESULT: nan
  printf("%a\n", div_f64(-0.0, 0.0));
  // RESULT: nan
  printf("%a\n", div_f64(0.0, -0.0));
  // RESULT: nan
  printf("%a\n", div_f64(-0.0, -0.0));
  // RESULT: nan

  return 0;
}

