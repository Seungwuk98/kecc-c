// RUN: kecc-test-executor %s -dump-source=0 | kecc-translate | FileCheck %s


fun i1 @ne_f32 (f32, f32) {
init:
  bid: b0
  allocations:

block b0:
  %b0:p0:f32
  %b0:p1:f32
  %b0:i0:i1 = cmp ne %b0:p0:f32 %b0:p1:f32
  ret %b0:i0:i1
}

// CHECK:   .globl	ne_f32
// CHECK-NEXT:   .align	1
// CHECK-NEXT:   .type	ne_f32, @function
// CHECK-NEXT: ne_f32:

// CHECK-LABEL: .ne_f32_L0:
// CHECK-NEXT:   feq.s	a0,fa0,fa1
// CHECK-NEXT:   xori	a0,a0,1
// CHECK-NEXT:   ret


fun i1 @ne_f64 (f64, f64) {
init:
  bid: b0
  allocations:

block b0:
  %b0:p0:f64
  %b0:p1:f64
  %b0:i0:i1 = cmp ne %b0:p0:f64 %b0:p1:f64
  ret %b0:i0:i1
}

// CHECK:   .globl	ne_f64
// CHECK-NEXT:   .align	1
// CHECK-NEXT:   .type	ne_f64, @function
// CHECK-NEXT: ne_f64:

// CHECK-LABEL: .ne_f64_L0:
// CHECK-NEXT:   feq.d	a0,fa0,fa1
// CHECK-NEXT:   xori	a0,a0,1
// CHECK-NEXT:   ret


//////// main.c 
// RUN: kecc-test-executor %s | FileCheck %s --check-prefix=RESULT

#include <stdio.h>
#include <stdint.h>
#include <math.h>

extern int ne_f32(float, float);
extern int ne_f64(double, double);

int main(void) {
  // ===== f32 (float) =====
  printf("%d\n", ne_f32(0.0f, 0.0f));
  // RESULT: 0
  printf("%d\n", ne_f32(0.0f, -0.0f));
  // RESULT: 0
  printf("%d\n", ne_f32(-0.0f, 0.0f));
  // RESULT: 0

  printf("%d\n", ne_f32(1.0f, 1.0f));
  // RESULT: 0
  printf("%d\n", ne_f32(1.0f, 0x1.000002p+0f));      // 1 vs nextafterf(1,+)
  // RESULT: 1
  printf("%d\n", ne_f32(0x1.000002p+0f, 1.0f));
  // RESULT: 1

  printf("%d\n", ne_f32(0x1p-149f, 0x1p-149f));      // min subnormal
  // RESULT: 0
  printf("%d\n", ne_f32(0x1p-149f, 0.0f));           // subnormal vs zero
  // RESULT: 1
  printf("%d\n", ne_f32(-0x1p-149f, 0.0f));
  // RESULT: 1

  printf("%d\n", ne_f32(0x1.fffffep+127f, 0x1.fffffep+127f)); // FLT_MAX
  // RESULT: 0
  printf("%d\n", ne_f32(0x1.fffffep+127f, INFINITY));
  // RESULT: 1
  printf("%d\n", ne_f32(INFINITY, INFINITY));
  // RESULT: 0
  printf("%d\n", ne_f32(-INFINITY, -INFINITY));
  // RESULT: 0
  printf("%d\n", ne_f32(INFINITY, -INFINITY));
  // RESULT: 1

  printf("%d\n", ne_f32(NAN, NAN));                  // NaN compares as not equal
  // RESULT: 1
  printf("%d\n", ne_f32(NAN, 1.0f));
  // RESULT: 1
  printf("%d\n", ne_f32(1.0f, NAN));
  // RESULT: 1

  printf("%d\n", ne_f32(1.0e-30f, 1.0e-30f));
  // RESULT: 0
  printf("%d\n", ne_f32(1.0e30f, 1.0e30f));
  // RESULT: 0

  // ===== f64 (double) =====
  printf("%d\n", ne_f64(0.0, 0.0));
  // RESULT: 0
  printf("%d\n", ne_f64(0.0, -0.0));
  // RESULT: 0
  printf("%d\n", ne_f64(-0.0, 0.0));
  // RESULT: 0

  printf("%d\n", ne_f64(1.0, 1.0));
  // RESULT: 0
  printf("%d\n", ne_f64(1.0, 0x1.0000000000001p+0)); // 1 vs nextafter(1,+)
  // RESULT: 1
  printf("%d\n", ne_f64(0x1.0000000000001p+0, 1.0));
  // RESULT: 1

  printf("%d\n", ne_f64(0x1p-1074, 0x1p-1074));      // min subnormal
  // RESULT: 0
  printf("%d\n", ne_f64(0x1p-1074, 0.0));
  // RESULT: 1
  printf("%d\n", ne_f64(-0x1p-1074, 0.0));
  // RESULT: 1

  printf("%d\n", ne_f64(0x1.fffffffffffffp+1023, 0x1.fffffffffffffp+1023)); // DBL_MAX
  // RESULT: 0
  printf("%d\n", ne_f64(0x1.fffffffffffffp+1023, INFINITY));
  // RESULT: 1
  printf("%d\n", ne_f64(INFINITY, INFINITY));
  // RESULT: 0
  printf("%d\n", ne_f64(-INFINITY, -INFINITY));
  // RESULT: 0
  printf("%d\n", ne_f64(INFINITY, -INFINITY));
  // RESULT: 1

  printf("%d\n", ne_f64(NAN, NAN));                  // NaN compares as not equal
  // RESULT: 1
  printf("%d\n", ne_f64(NAN, 1.0));
  // RESULT: 1
  printf("%d\n", ne_f64(1.0, NAN));
  // RESULT: 1

  printf("%d\n", ne_f64(1.0e-300, 1.0e-300));
  // RESULT: 0
  printf("%d\n", ne_f64(1.0e300, 1.0e300));
  // RESULT: 0

  return 0;
}

