// RUN: kecc-test-executor %s --dump-source=0 | kecc-translate | FileCheck %s

struct S : {a:i32, b:i32, c:i32}


// CHECK: .globl addS
// CHECK-NEXT: .align 1 
// CHECK-NEXT: .type addS, @function
fun struct S @addS(struct S /* l */, struct S /* r */) {
// CHECK-NEXT: addS:
init:
  bid: b0
  allocations:
    %l0:struct S:l
    %l1:struct S:r
    %l2:struct S:result
    // %l3:[2 x i64]
  // CHECK-NEXT: addi sp,sp,-108
  // CHECK-NEXT: sd ra,100(sp)

  /// callee-saved registers
  // CHECK-NEXT: sd s0,68(sp)
  // CHECK-NEXT: sd s1,76(sp)
  // CHECK-NEXT: sd s2,84(sp)
  // CHECK-NEXT: sd s3,92(sp)

  /// local variables
  // CHECK-NEXT: addi [[L0_REG:[a-z][0-9]+]],sp,0
  // CHECK-NEXT: addi [[L1_REG:[a-z][0-9]+]],sp,12
  // CHECK-NEXT: addi [[L2_REG:[a-z][0-9]+]],sp,24
  // CHECK-NEXT: addi [[L3_REG:[a-z][0-9]+]],sp,36

block b0: 
// CHECK-LABEL: .addS_L0:
  %b0:p0:struct S:l
  %b0:p1:struct S:r

  /// init memory
  // CHECK-NEXT: addiw [[ZERO:[a-z][0-9]+]],zero,0
  // CHECK-NEXT: sd [[ZERO]],0([[L3_REG]])
  // CHECK-NEXT: addi [[ARRAY_1_MEM:[a-z][0-9]+]],[[L3_REG]],8
  // CHECK-NEXT: addiw [[ZERO2:[a-z][0-9]+]],zero,0
  // CHECK-NEXT: sd [[ZERO2]],0([[ARRAY_1_MEM]])

  %b0:i0:unit = store %b0:p0:struct S %l0:struct S*
  /// store a0, a1 into %l3
  // CHECK-NEXT: sd a0,0([[L3_REG]])
  // CHECK-NEXT: addi [[TEMP_MEM0:[a-z][0-9]+]],[[L3_REG]],8
  // CHECK-NEXT: sd a1,0([[TEMP_MEM0]])

  /// memcpy l3 into l0
  // CHECK-NEXT: addiw [[SIZE0:[a-z][0-9]+]],zero,12  
  
  /// caller save
  // CHECK: sd a2,52(sp)
  // CHECK-NEXT: sd a3,60(sp)

  // call
  // CHECK: mv a1,[[L3_REG]]
  // CHECK-NEXT: mv a2,[[SIZE0]]
  // CHECK-NEXT: mv a0,[[L0_REG]]
  // CHECK-NEXT: call memcpy

  /// caller restore
  // CHECK: ld a2,52(sp)
  // CHECK-NEXT: ld a3,60(sp)


  %b0:i1:unit = store %b0:p1:struct S %l1:struct S*
  /// store a2, a3 into %l3
  // CHECK: sd a2,0([[L3_REG]])
  // CHECK-NEXT: addi [[TEMP_MEM1:[a-z][0-9]+]],[[L3_REG]],8
  // CHECK-NEXT: sd a3,0([[TEMP_MEM1]])

  /// memcpy l3 into l1
  // CHECK-NEXT: addiw [[SIZE1:[a-z][0-9]+]],zero,12

  // no caller save
  // CHECK-NEXT: mv a1,[[L3_REG]]
  // CHECK-NEXT: mv a2,[[SIZE1]]
  // CHECK-NEXT: mv a0,[[L1_REG]]
  // CHECK-NEXT: call memcpy


  // load l.a
  %b0:i2:i32* = getelementptr %l0:struct S* offset 0:i64
  %b0:i3:i32 = load %b0:i2:i32*
  // CHECK-NEXT: lw [[L_A:[a-z][0-9]+]],0([[L0_REG]])

  // load r.a
  %b0:i4:i32* = getelementptr %l1:struct S* offset 0:i64
  %b0:i5:i32 = load %b0:i4:i32*
  // CHECK-NEXT: lw [[R_A:[a-z][0-9]+]],0([[L1_REG]])

  // l.a + r.a
  %b0:i6:i32 = add %b0:i3:i32 %b0:i5:i32
  // CHECK-NEXT: addw [[ADD_A:[a-z][0-9]+]],[[L_A]],[[R_A]]

  // load l.b
  %b0:i7:i32* = getelementptr %l0:struct S* offset 4:i64
  // CHECK-NEXT: addi [[L_B_M:[a-z][0-9]+]],[[L0_REG]],4
  %b0:i8:i32 = load %b0:i7:i32*
  // CHECK-NEXT: lw [[L_B:[a-z][0-9]+]],0([[L_B_M]])

  // load r.b
  %b0:i9:i32* = getelementptr %l1:struct S* offset 4:i64
  // CHECK-NEXT: addi [[R_B_M:[a-z][0-9]+]],[[L1_REG]],4
  %b0:i10:i32 = load %b0:i9:i32*
  // CHECK-NEXT: lw [[R_B:[a-z][0-9]+]],0([[R_B_M]])

  // l.b + r.b
  %b0:i11:i32 = add %b0:i8:i32 %b0:i10:i32
  // CHECK-NEXT: addw [[ADD_B:[a-z][0-9]+]],[[L_B]],[[R_B]]

  // load l.c
  %b0:i12:i32* = getelementptr %l0:struct S* offset 8:i64
  // CHECK-NEXT: addi [[L_C_M:[a-z][0-9]+]],[[L0_REG]],8
  %b0:i13:i32 = load %b0:i12:i32*
  // CHECK-NEXT: lw [[L_C:[a-z][0-9]+]],0([[L_C_M]])

  // load r.c
  %b0:i14:i32* = getelementptr %l1:struct S* offset 8:i64
  // CHECK-NEXT: addi [[R_C_M:[a-z][0-9]+]],[[L1_REG]],8
  %b0:i15:i32 = load %b0:i14:i32*
  // CHECK-NEXT: lw [[R_C:[a-z][0-9]+]],0([[R_C_M]])

  // l.c + r.c
  %b0:i16:i32 = add %b0:i13:i32 %b0:i15:i32
  // CHECK-NEXT: addw [[ADD_C:[a-z][0-9]+]],[[L_C]],[[R_C]]

  // store into result
  
  %b0:i17:i32* = getelementptr %l2:struct S* offset 0:i64
  // CHECK-NEXT: mv [[ADD_A_M:[a-z][0-9]+]],[[L2_REG]]
  %b0:i18:unit = store %b0:i6:i32 %b0:i17:i32*
  // CHECK-NEXT: sw [[ADD_A]],0([[ADD_A_M]])

  %b0:i19:i32* = getelementptr %l2:struct S* offset 4:i64
  // CHECK-NEXT: addi [[ADD_B_M:[a-z][0-9]+]],[[L2_REG]],4
  %b0:i20:unit = store %b0:i11:i32 %b0:i19:i32*
  // CHECK-NEXT: sw [[ADD_B]],0([[ADD_B_M]])

  %b0:i21:i32* = getelementptr %l2:struct S* offset 8:i64
  // CHECK-NEXT: addi [[ADD_C_M:[a-z][0-9]+]],[[L2_REG]],8
  %b0:i22:unit = store %b0:i16:i32 %b0:i21:i32*
  // CHECK-NEXT: sw [[ADD_C]],0([[ADD_C_M]])

  %b0:i23:struct S = load %l2:struct S*
  // memcpy l2 into l3

  // CHECK-NEXT: addiw [[SIZE2:[a-z][0-9]+]],zero,12 
  // CHECK-NEXT: mv a0,[[L3_REG]]
  // CHECK-NEXT: mv a1,[[L2_REG]]
  // CHECK-NEXT: mv a2,[[SIZE2]]
  // CHECK-NEXT: call memcpy

  // load i64 from l3
  // CHECK-NEXT: mv [[TEMP_MEM2:[a-z][0-9]+]],[[L3_REG]]
  // CHECK-NEXT: ld [[RET0:[a-z][0-9]+]],0([[TEMP_MEM2]])
  // CHECK-NEXT: addi [[TEMP_MEM3:[a-z][0-9]+]],[[L3_REG]],8 
  // CHECK-NEXT: ld [[RET1:[a-z][0-9]+]],0([[TEMP_MEM3]])
  // CHECK-NEXT: mv a0,[[RET0]]
  // CHECK-NEXT: mv a1,[[RET1]]

  ret %b0:i23:struct S
  /// callee-saved registers
  // CHECK-NEXT: ld s0,68(sp)
  // CHECK-NEXT: ld s1,76(sp)
  // CHECK-NEXT: ld s2,84(sp)
  // CHECK-NEXT: ld s3,92(sp)

  // CHECK-NEXT: ld ra,100(sp)
  // CHECK-NEXT: addi sp,sp,108
}
