#ifndef KECC_IR_INTERPRETER_H
#define KECC_IR_INTERPRETER_H

#include "kecc/ir/IR.h"
#include "kecc/ir/IRInstructions.h"
#include "kecc/ir/Module.h"
#include "kecc/ir/Value.h"
#include "llvm/ADT/APFloat.h"
#include "llvm/ADT/APSInt.h"
#include "llvm/Support/Allocator.h"
#include "llvm/Support/MemAlloc.h"

namespace kecc::ir {

class InterpreterContext {
public:
private:
  llvm::BumpPtrAllocator allocator;
};

class VRegister {
public:
  enum Kind {
    Int,
    Float,
    Struct,
  };

  VRegister(Kind kind) : kind(kind) {}

  virtual ~VRegister() = default;

  Kind getKind() const { return kind; }

  void dump() const;
  virtual void print(llvm::raw_ostream &os) const = 0;

  static llvm::StringRef kindToString(Kind kind);

private:
  Kind kind;
};

class VMemory {
public:
  VMemory() : size(0), data(nullptr) {}
  VMemory(size_t size, void *data) : size(size), data(data) {}
  ~VMemory() = default;

  void *getData() const { return data; }
  void *getElementPtr(std::size_t offset) const;

private:
  size_t size;
  void *data;
};

class VRegisterInt : public VRegister {
public:
  VRegisterInt() : VRegister(Kind::Int), value(0) {}
  VRegisterInt(std::uint64_t v) : VRegister(Kind::Int), value(v) {}

  std::uint64_t getValue() const { return value; }
  void setValue(std::uint64_t v) { value = v; }

  llvm::APSInt getAsInteger(unsigned bitWidth, bool isSigned) const;
  VMemory getAsMemory() const;

  static bool classof(const VRegister *v) { return v->getKind() == Kind::Int; }
  void print(llvm::raw_ostream &os) const override;

private:
  union {
    std::uint64_t value;
    VMemory memory;
  };
};

class VRegisterFloat : public VRegister {
public:
  VRegisterFloat() : VRegister(Kind::Float), value(0) {}
  VRegisterFloat(std::uint64_t v) : VRegister(Kind::Float), value(v) {}

  std::uint64_t getValue() const { return value; }
  void setValue(llvm::APFloat v);

  llvm::APFloat getAsFloat(int bitwidth) const;
  void print(llvm::raw_ostream &os) const override;

  static bool classof(const VRegister *v) {
    return v->getKind() == Kind::Float;
  }

private:
  std::uint64_t value;
};

class VRegisterStruct : public VRegister {
public:
  VRegisterStruct() : VRegister(Kind::Struct), size(0), data(nullptr) {}
  VRegisterStruct(size_t size, void *data)
      : VRegister(Kind::Struct), size(size), data(llvm::safe_malloc(size)) {}
  ~VRegisterStruct() {
    if (data)
      free(data);
  }

  void *getData() const { return data; }
  static bool classof(const VRegister *v) {
    return v->getKind() == Kind::Struct;
  }

  void memcpy(VMemory src, std::size_t size);
  void print(llvm::raw_ostream &os) const override;

private:
  size_t size;
  void *data;
};

class StackFrame {
public:
  StackFrame(InterpreterContext *interpCtx, ir::Function *function)
      : interpCtx(interpCtx), function(function) {
    initRegisters();
  }
  ~StackFrame();

  ir::Function *getFunction() const { return function; }

  VRegister *getRegister(ir::Value v) const {
    auto it = registers.find(v);
    if (it != registers.end()) {
      return it->second.get();
    }
    return nullptr;
  }

private:
  void initRegisters();

  InterpreterContext *interpCtx;
  ir::Function *function;
  void *frameMem;
  size_t frameSize;
  llvm::DenseMap<ir::inst::LocalVariable, VMemory> localVars;
  llvm::DenseMap<ir::Value, std::unique_ptr<VRegister>> registers;
};

class Interpreter {
public:
  Interpreter(InterpreterContext *interpCtx, ir::Module *module)
      : interpCtx(interpCtx), module(module) {}

  struct CallStack {
    CallStack(Interpreter *interpreter, ir::Function *function)
        : interpreter(interpreter) {
      interpreter->callStack.emplace_back(std::unique_ptr<StackFrame>(
          new StackFrame(interpreter->interpCtx, function)));
    }
    ~CallStack() { interpreter->callStack.pop_back(); }

  private:
    Interpreter *interpreter;
  };

  llvm::SmallVector<std::unique_ptr<VRegister>>
  call(llvm::StringRef name, llvm::ArrayRef<VRegister *> args);

private:
  InterpreterContext *interpCtx;
  llvm::SmallVector<std::unique_ptr<StackFrame>> callStack;
  ir::Module *module;
};

} // namespace kecc::ir

#endif // KECC_IR_INTERPRETER_H
